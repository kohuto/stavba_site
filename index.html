<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interaktivn√≠ graf</title>
  <style>
    /* Z√°kladn√≠ reset a nastaven√≠ fontu */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f4f4f4;
    }
    .container {
      max-width: 1200px;
      margin: auto;
      padding: 20px;
    }
    /* Styl pro legendu */
    #legend {
      background: #fff;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    #legend ul {
      list-style: none;
      padding-left: 20px;
    }
    #legend li {
      margin-bottom: 5px;
    }
    /* Paleta pro nov√© uzly ‚Äì obr√°zky p≈ô√≠mo */
    #nodePalette {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
    }
    .paletteItem {
      max-width: 100px;
      max-height: 100px;
      padding: 10px;
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      cursor: move;
      transition: transform 0.2s;
    }
    .paletteItem:hover {
      transform: scale(1.05);
    }
    /* Wrapper pro canvas a tlaƒç√≠tko s relativn√≠m pozicov√°n√≠m */
    #canvasWrapper {
      position: relative;
    }
    /* Tlaƒç√≠tko um√≠stƒõn√© v prav√©m horn√≠m rohu kresl√≠c√≠ plochy */
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      display: flex;
      gap: 10px;
    }
    button {
      padding: 10px 20px;
      border: none;
      background: #007BFF;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background: #0056b3;
    }
    /* Responzivn√≠ canvas */
    canvas {
      background: #fff;
      border: 1px solid #ccc;
      width: 100%;
      height: auto;
      display: block;
    }
    /* Stylov√°n√≠ n√°vodu */
#instructions {
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  padding: 20px;
  margin-bottom: 20px;
}

#instructions h2 {
  margin-top: 0;
  font-size: 1.8em;
  border-bottom: 2px solid #007BFF;
  padding-bottom: 8px;
  color: #007BFF;
  text-align: center;
}

.instruction-row {
  display: flex;
  flex-wrap: nowrap;
  justify-content: space-between;
  gap: 10px;
}

.instruction-item {
  flex: 1;
  background-color: #f9f9f9;
  border-radius: 6px;
  padding: 10px 15px;
  transition: background-color 0.2s;
  display: flex;
  align-items: flex-start;
  min-width: 0;
}

.instruction-item:hover {
  background-color: #eef6ff;
}

.instruction-icon {
  font-size: 1.5em;
  margin-right: 10px;
  width: 40px;
  text-align: center;
  flex-shrink: 0;
}

.instruction-content {
  display: flex;
  flex-direction: column;
}

.instruction-header {
  font-family: 'Segoe UI', sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  margin-bottom: 4px;
  color: #333;
}

.instruction-detail {
  font-family: 'Verdana', sans-serif;
  font-size: 0.95em;
  color: #555;
}
.instruction-header {
  font-family: 'Segoe UI', sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  color: #333;
  height: 30px;             /* Pevnƒõ dan√° v√Ω≈°ka z√°hlav√≠ */
  line-height: 30px;        /* Vertik√°ln√≠ centrov√°n√≠ textu */
  border-bottom: 1px solid #ccc; /* Jemn√© oddƒõlen√≠ z√°hlav√≠ */
  margin-bottom: 8px;       /* Odstup pod z√°hlav√≠m */
}

.instruction-detail {
  font-family: 'Verdana', sans-serif;
  font-size: 0.95em;
  color: #555;
  padding-top: 5px;         /* Jemn√Ω odsazen√≠ od z√°hlav√≠ */
}



  </style>
</head>
<body>
  <div class="container">
   <!-- Upraven√Ω n√°vod -->
<div id="instructions">
  <h2>N√°vod</h2>
  <div class="instruction-row">
    <div class="instruction-item">
      <div class="instruction-icon">‚ûï</div>
      <div class="instruction-content">
        <div class="instruction-header">P≈ôid√°n√≠ za≈ô√≠zen√≠</div>
        <div class="instruction-detail">P≈ôet√°hnƒõte obr√°zek z nab√≠dky na plochu.</div>
      </div>
    </div>
    <div class="instruction-item">
      <div class="instruction-icon">üîó</div>
      <div class="instruction-content">
        <div class="instruction-header">Vytv√°≈ôen√≠ cest</div>
        <div class="instruction-detail">T√°hnƒõte cestu z jednoho za≈ô√≠zen√≠ na druh√Ω.</div>
      </div>
    </div>
    <div class="instruction-item">
      <div class="instruction-icon">üîÄ</div>
      <div class="instruction-content">
        <div class="instruction-header">P≈ôesun za≈ô√≠zen√≠</div>
        <div class="instruction-detail">Dr≈æte Shift a tahejte za≈ô√≠zen√≠.</div>
      </div>
    </div>
    <div class="instruction-item">
      <div class="instruction-icon">‚ùå</div>
      <div class="instruction-content">
        <div class="instruction-header">Smaz√°n√≠ cesty</div>
        <div class="instruction-detail">Kliknƒõte na cestu.</div>
      </div>
    </div>
    <div class="instruction-item">
      <div class="instruction-icon">üóëÔ∏è</div>
      <div class="instruction-content">
        <div class="instruction-header">Smaz√°n√≠ za≈ô√≠zen√≠</div>
        <div class="instruction-detail">Dvakr√°t kliknƒõte na za≈ô√≠zen√≠.</div>
      </div>
    </div>
  </div>
</div>


    <!-- Paleta pro nov√© uzly ‚Äì obr√°zkov√© mo≈ænosti -->
    <div id="nodePalette">
      <img class="paletteItem" id="newNodeChytra" draggable="true" data-type="chytrakrizovatka_kratka" src="chytrakrizovatka_kratka.svg" alt="Chytrak≈ôi≈æovatka">
      <img class="paletteItem" id="newNodeServer" draggable="true" data-type="server" src="server.svg" alt="Server">
      <img class="paletteItem" id="newNodeBts" draggable="true" data-type="bts" src="bts.svg" alt="BTS">
      <img class="paletteItem" id="newNodeWifi" draggable="true" data-type="wifi" src="wifi.svg" alt="WiFi">
      <img class="paletteItem" id="newNodePC" draggable="true" data-type="pc" src="pc.svg" alt="PC">
      <img class="paletteItem" id="newNodeNotebook" draggable="true" data-type="notebook" src="notebook.svg" alt="Notebook">
      <img class="paletteItem" id="newNodeMobil" draggable="true" data-type="mobil" src="mobil.svg" alt="Mobil">
    </div>
    <!-- Canvas a ovl√°dac√≠ tlaƒç√≠tko -->
    <div id="canvasWrapper">
      <canvas id="graphCanvas" width="800" height="600"></canvas>
      <div id="controls">
        <button id="resetBtn">Reset</button>
        <button id="exportBtn">Export PNG</button>
      </div>
    </div>
  </div>
  
  <script>
    document.getElementById("exportBtn").addEventListener("click", () => {
  const link = document.createElement('a');
  link.download = 'graph.png';
  link.href = canvas.toDataURL("image/png");
  link.click();
});

    /* Ulo≈æen√≠ p≈Øvodn√≠ho stavu s√≠tƒõ ‚Äì u uzl≈Ø nastavujeme vlastnost type */
    const initialNodes = [];

    const initialEdges = [];

    // Pracovn√≠ kopie uzl≈Ø a hran
    let nodes = JSON.parse(JSON.stringify(initialNodes));
    let edges = JSON.parse(JSON.stringify(initialEdges));

    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');

    // Promƒõnn√© pro tvorbu hran
    let dragStartNode = null;
    let isDragging = false;
    let currentMousePos = { x: 0, y: 0 };

    // Promƒõnn√© pro p≈ôesouv√°n√≠ uzl≈Ø
    let movingNode = null;
    let isMoving = false;

    // Nastav√≠me maxim√°ln√≠ velikost uzlu (≈°√≠≈ôka/v√Ω≈°ka)
    const nodeSize = 150;
    const nodeSizes = {
  "chytrakrizovatka_kratka": 120,
  "server": 100,
  "bts": 200,
  "wifi": 70,
  "pc": 80,
  "notebook": 70,
  "mobil": 60
};


    // Objekt s obr√°zky pro jednotliv√© typy uzl≈Ø
    const images = {
      "chytrakrizovatka_kratka": new Image(),
      "server": new Image(),
      "bts": new Image(),
      "wifi": new Image(),
      "pc": new Image(),
      "notebook": new Image(),
      "mobil": new Image()
    };
    images.chytrakrizovatka_kratka.crossOrigin = "anonymous";
    images.chytrakrizovatka_kratka.src = "chytrakrizovatka_kratka.svg";
    images.server.crossOrigin = "anonymous";
    images.server.src = "server.svg";
    images.bts.crossOrigin = "anonymous";
    images.bts.src = "bts.svg";
    images.wifi.crossOrigin = "anonymous";
    images.wifi.src = "wifi.svg";
    images.pc.crossOrigin = "anonymous";
    images.pc.src = "pc.svg";
    images.notebook.crossOrigin = "anonymous";
    images.notebook.src = "notebook.svg";
    images.mobil.crossOrigin = "anonymous";
    images.mobil.src = "mobil.svg";

    // Obsluha naƒçten√≠ nebo chyby obr√°zk≈Ø ‚Äì jednoduch√Ω onload, pot√© se vykresl√≠ graf
    images.chytrakrizovatka_kratka.onload = images.server.onload = 
    images.bts.onload = images.wifi.onload = images.pc.onload = images.notebook.onload = images.mobil.onload = () => { drawGraph(); };
    // P≈ô√≠padnƒõ, pokud obr√°zky sel≈æou, se pou≈æije fallback (kreslen√≠ uzlu jako kruhu)
    drawGraph();

    // P≈ôepoƒç√≠t√° pozici my≈°i na vnit≈ôn√≠ rozli≈°en√≠ canvasu
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
  return {
    x: evt.clientX - rect.left,
    y: evt.clientY - rect.top
  };
    }

    // Vr√°t√≠ uzel, pokud je bod uvnit≈ô oblasti uzlu
    function nodeAtPos(pos) {
  return nodes.find(node => {
    const currentSize = nodeSizes[node.type] || 80;
    let rect = null;
    let img = images[node.type];
    if (img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
      const scale = Math.min(currentSize / img.naturalWidth, currentSize / img.naturalHeight);
      const drawWidth = img.naturalWidth * scale;
      const drawHeight = img.naturalHeight * scale;
      rect = {
        x: node.x - drawWidth / 2,
        y: node.y - drawHeight / 2,
        width: drawWidth,
        height: drawHeight
      };
    } else {
      const half = currentSize / 2;
      rect = {
        x: node.x - half,
        y: node.y - half,
        width: currentSize,
        height: currentSize
      };
    }
    return (pos.x >= rect.x && pos.x <= rect.x + rect.width &&
            pos.y >= rect.y && pos.y <= rect.y + rect.height);
  });
}


    // V√Ωpoƒçet vzd√°lenosti bodu od √∫seƒçky (pro detekci kliknut√≠ na hranu)
    function pointLineDistance(point, lineStart, lineEnd) {
      const A = point.x - lineStart.x;
      const B = point.y - lineStart.y;
      const C = lineEnd.x - lineStart.x;
      const D = lineEnd.y - lineStart.y;
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = lenSq ? dot / lenSq : -1;
      let xx, yy;
      if (param < 0) { 
        xx = lineStart.x; 
        yy = lineStart.y; 
      } else if (param > 1) { 
        xx = lineEnd.x; 
        yy = lineEnd.y; 
      } else { 
        xx = lineStart.x + param * C; 
        yy = lineStart.y + param * D; 
      }
      const dx = point.x - xx;
      const dy = point.y - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Zjist√≠, zda bylo kliknuto na hranu ‚Äì plat√≠ i pro p≈Øvodn√≠ hrany
    function edgeAtPos(pos) {
      for (let i = 0; i < edges.length; i++) {
        const edge = edges[i];
        const nodeA = nodes.find(n => n.id === edge.from);
        const nodeB = nodes.find(n => n.id === edge.to);
        if (!nodeA || !nodeB) continue;
        const dist = pointLineDistance(pos, nodeA, nodeB);
        if (dist < 20) {
          return { edge, index: i };
        }
      }
      return null;
    }

    // Vykreslen√≠ grafu ‚Äì hrany a uzly (bez ƒç√≠sel)
    // Animaƒçn√≠ smyƒçka, kter√° plynule aktualizuje currentScale u ka≈æd√©ho uzlu
function animateNodes() {
  const hoveredNode = nodeAtPos(currentMousePos); // zjist√≠me, kter√Ω uzel je hoverovan√Ω
  nodes.forEach(node => {
    // C√≠lov√© mƒõ≈ô√≠tko: pokud je uzel hoverovan√Ω, c√≠lov√© scale je 1.1, jinak 1.
    const targetScale = (hoveredNode && hoveredNode.id === node.id) ? 1.1 : 1;
    // Pokud currentScale nen√≠ definov√°no, inicializujeme na 1.
    if (typeof node.currentScale === 'undefined') {
      node.currentScale = 1;
    }
    // Plynul√© zmƒõny (easing) ‚Äì ƒç√≠m men≈°√≠ hodnota, t√≠m pomalej≈°√≠ animace.
    node.currentScale += (targetScale - node.currentScale) * 0.1;
  });
  drawGraph();
  requestAnimationFrame(animateNodes);
}

// Spust√≠me animaƒçn√≠ smyƒçku
animateNodes();

function drawGraph() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Nejprve vykresl√≠me hrany
  edges.forEach((edge, i) => {
    const nodeA = nodes.find(n => n.id === edge.from);
    const nodeB = nodes.find(n => n.id === edge.to);
    if (!nodeA || !nodeB) return;
    // Pokud je tato hrana hoverovan√°, interpolujeme barvu mezi ƒçernou a svƒõtle ≈°edou:
    if (i === hoveredEdgeIndex) {
      const r = Math.round(211 * edgeHoverTransition);
      ctx.strokeStyle = `rgb(${r}, ${r}, ${r})`;
    } else {
      ctx.strokeStyle = "black";
    }
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(nodeA.x, nodeA.y);
    ctx.lineTo(nodeB.x, nodeB.y);
    ctx.stroke();
  });

  // N√°hled hrany p≈ôi tvorbƒõ (drag and drop)
  if (isDragging && dragStartNode) {
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(dragStartNode.x, dragStartNode.y);
    ctx.lineTo(currentMousePos.x, currentMousePos.y);
    ctx.stroke();
  }

  // Zjist√≠me, kter√© uzly typu "bts" maj√≠ spojen√≠ s "chytrakrizovatka_kratka"
  const highlightedBts = new Set();
  const highlightedWifi = new Set();
  edges.forEach(edge => {
    const nodeA = nodes.find(n => n.id === edge.from);
    const nodeB = nodes.find(n => n.id === edge.to);
    if (nodeA && nodeB) {
      if (nodeA.type === "bts" && nodeB.type === "chytrakrizovatka_kratka") {
        highlightedBts.add(nodeA.id);
      }
      if (nodeB.type === "bts" && nodeA.type === "chytrakrizovatka_kratka") {
        highlightedBts.add(nodeB.id);
      }
      if (nodeA.type === "wifi" && nodeB.type === "chytrakrizovatka_kratka") {
        highlightedWifi.add(nodeA.id);
      }
      if (nodeB.type === "wifi" && nodeA.type === "chytrakrizovatka_kratka") {
        highlightedWifi.add(nodeB.id);
      }
    }
  });
  
  // Konstanta urƒçuj√≠c√≠ polomƒõr zv√Ωraz≈àuj√≠c√≠ho kruhu (m≈Ø≈æete upravit)
  const btsHighlightRadius = 300;
  const wifiHighlightRadius = 100;

  // Vykreslen√≠ uzl≈Ø
  nodes.forEach(node => {
    const currentSize = nodeSizes[node.type] || 80;
    // Plynul√© zvƒõt≈°en√≠ u≈æ m√°me implementov√°no p≈ôes currentScale (u hover efektu)
    const sizeToUse = currentSize * (node.currentScale || 1);
    let img = images[node.type];
    
    // Zv√Ωraznƒõn√≠ pro uzly typu "bts"
  if (node.type === "bts" && highlightedBts.has(node.id)) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(node.x, node.y, btsHighlightRadius, 0, 2 * Math.PI);
    // Pou≈æijeme jemnou ƒç√°rkovanou ƒç√°ru s ≈°ed√Ωm odst√≠nem
    ctx.strokeStyle = "rgba(128, 128, 128, 0.7)";
    ctx.lineWidth = 3;
    ctx.setLineDash([4, 4]); // 4px ƒç√°ra, 4px mezera
    ctx.stroke();
    ctx.restore();
  }
  
  // Zv√Ωraznƒõn√≠ pro uzly typu "wifi"
  if (node.type === "wifi" && highlightedWifi.has(node.id)) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(node.x, node.y, wifiHighlightRadius, 0, 2 * Math.PI);
    // Pou≈æijeme lehce svƒõtlej≈°√≠ ≈°ed√Ω odst√≠n
    ctx.strokeStyle = "rgba(160, 160, 160, 0.7)";
    ctx.lineWidth = 3;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.restore();
  }

    if (img && img.complete && img.naturalWidth > 0) {
      const scale = Math.min(sizeToUse / img.naturalWidth, sizeToUse / img.naturalHeight);
      const drawWidth = img.naturalWidth * scale;
      const drawHeight = img.naturalHeight * scale;
      ctx.drawImage(img, node.x - drawWidth / 2, node.y - drawHeight / 2, drawWidth, drawHeight);
    } else {
      const half = sizeToUse / 2;
      ctx.beginPath();
      ctx.arc(node.x, node.y, half, 0, 2 * Math.PI);
      ctx.fillStyle = "white";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "black";
      ctx.stroke();
    }
  });
}


    
 // Aktualizace pozice my≈°i a nastaven√≠ kurzoru p≈ôi pohybu my≈°i
// Glob√°ln√≠ promƒõnn√° pro index hoverovan√© hrany
let hoveredEdgeIndex = -1;
let edgeHoverTarget = 0;      // 1 = c√≠lov√° barva (svƒõtle ≈°ed√°), 0 = ƒçern√°
let edgeHoverTransition = 0;  // aktu√°ln√≠ p≈ôechodov√° hodnota


canvas.addEventListener("mousemove", (evt) => {
  currentMousePos = getMousePos(evt);
  const hoveredNode = nodeAtPos(currentMousePos);

  if (hoveredNode) {
    hoveredEdgeIndex = -1;
    edgeHoverTarget = 0; // kdy≈æ jsme nad uzlem, ≈æ√°dn√° hrana nem√° b√Ωt hoverovan√°
    canvas.style.cursor = evt.shiftKey ? "grab" : "crosshair";
  } else {
    const hoveredEdge = edgeAtPos(currentMousePos);
    if (hoveredEdge) {
      hoveredEdgeIndex = hoveredEdge.index;
      edgeHoverTarget = 1;
      canvas.style.cursor = "default";
    } else {
      hoveredEdgeIndex = -1;
      edgeHoverTarget = 0;
      canvas.style.cursor = "default";
    }
  }
  
  if (isMoving && movingNode) {
    movingNode.x = currentMousePos.x;
    movingNode.y = currentMousePos.y;
  }
  
  drawGraph();
});
function animate() {
  // Plynul√° zmƒõna edgeHoverTransition smƒõrem k edgeHoverTarget.
  edgeHoverTransition += (edgeHoverTarget - edgeHoverTransition) * 0.1;
  
  drawGraph();
  requestAnimationFrame(animate);
}
animate();


// Funkce aktualizuj√≠c√≠ kurzor podle aktu√°ln√≠ho stavu Shift a pozice my≈°i
function updateCursor(shiftPressed) {
  const hoveredNode = nodeAtPos(currentMousePos);
  if (hoveredNode) {
    canvas.style.cursor = shiftPressed ? "grab" : "crosshair";
  }
}

window.addEventListener("keydown", (evt) => {
  if (evt.key === "Shift") updateCursor(true);
});
window.addEventListener("keyup", (evt) => {
  if (evt.key === "Shift") updateCursor(false);
});






    // Kliknut√≠ na hranu pro jej√≠ smaz√°n√≠
    canvas.addEventListener("click", (evt) => {
      const pos = getMousePos(evt);
      if (nodeAtPos(pos)) return;
      const clickedEdge = edgeAtPos(pos);
      if (clickedEdge) {
        edges.splice(clickedEdge.index, 1);
        drawGraph();
      }
    });
    
    // mousedown: rozli≈°ujeme re≈æim p≈ôesunu uzlu (Shift) nebo tvorbu hrany (bez Shift)
    canvas.addEventListener("mousedown", (evt) => {
      const pos = getMousePos(evt);
      const node = nodeAtPos(pos);
      if (node) {
        if (evt.shiftKey) {
          movingNode = node;
          isMoving = true;
        } else {
          dragStartNode = node;
          isDragging = true;
        }
      }
    });

    // mousemove: pokud p≈ôesouv√°me uzel, aktualizujeme jeho pozici; jinak jen vykreslujeme n√°hled hrany
    canvas.addEventListener("mousemove", (evt) => {
      currentMousePos = getMousePos(evt);
      if (isMoving && movingNode) {
        movingNode.x = currentMousePos.x;
        movingNode.y = currentMousePos.y;
        drawGraph();
      } else if (isDragging) {
        drawGraph();
      }
    });

    // mouseup: ukonƒç√≠me re≈æim p≈ôesunu nebo tvorbu hrany
    canvas.addEventListener("mouseup", (evt) => {
      if (isMoving) {
        isMoving = false;
        movingNode = null;
      } else if (isDragging && dragStartNode) {
        const pos = getMousePos(evt);
        const endNode = nodeAtPos(pos);
        if (endNode && endNode.id !== dragStartNode.id) {
          const exists = edges.some(e =>
            (e.from === dragStartNode.id && e.to === endNode.id) ||
            (e.from === endNode.id && e.to === dragStartNode.id)
          );
          if (!exists) {
            edges.push({ from: dragStartNode.id, to: endNode.id, isNew: true });
          }
        }
        isDragging = false;
        dragStartNode = null;
      }
      drawGraph();
    });


    // Dvojklik na uzel ‚Äì smaz√°n√≠ uzlu a v≈°ech jeho hran
    canvas.addEventListener("dblclick", (evt) => {
      const pos = getMousePos(evt);
      const node = nodeAtPos(pos);
      if (node) {
        nodes = nodes.filter(n => n.id !== node.id);
        edges = edges.filter(e => e.from !== node.id && e.to !== node.id);
        drawGraph();
      }
    });

    // Obsluha dragstart pro polo≈æky v paletƒõ ‚Äì nastav√≠me typ uzlu
    document.querySelectorAll(".paletteItem").forEach(item => {
      item.addEventListener("dragstart", (evt) => {
        const nodeType = evt.target.getAttribute("data-type");
        evt.dataTransfer.setData("nodeType", nodeType);
      });
    });

    // Obsluha dragover a drop na canvasu pro p≈ôid√°n√≠ nov√©ho uzlu
    canvas.addEventListener("dragover", (evt) => {
      evt.preventDefault();
    });
    canvas.addEventListener("drop", (evt) => {
      evt.preventDefault();
      const nodeType = evt.dataTransfer.getData("nodeType");
      if (nodeType) {
        const pos = getMousePos(evt);
        const newId = nodes.length ? Math.max(...nodes.map(n => n.id)) + 1 : 1;
        nodes.push({ id: newId, x: pos.x, y: pos.y, type: nodeType });
        drawGraph();
      }
    });

    // Reset tlaƒç√≠tko ‚Äì obnov√≠ p≈Øvodn√≠ s√≠≈•
    document.getElementById("resetBtn").addEventListener("click", () => {
      nodes = JSON.parse(JSON.stringify(initialNodes));
      edges = JSON.parse(JSON.stringify(initialEdges));
      drawGraph();
    });

    // Responzivn√≠ design: p≈ôi zmƒõnƒõ velikosti okna se canvas ≈°k√°luje
    function resizeCanvas() {
      // Zjist√≠me aktu√°ln√≠ rozmƒõry z CSS
  const displayWidth = canvas.clientWidth;
  const displayHeight = canvas.clientHeight;
  // Z√≠sk√°me devicePixelRatio
  const ratio = window.devicePixelRatio || 1;
  // Nastav√≠me skuteƒçnou velikost canvasu
  canvas.width = displayWidth * ratio;
  canvas.height = displayHeight * ratio;
  // Resetujeme transformaci a nastav√≠me mƒõ≈ô√≠tko
  ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  drawGraph();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
  </script>
</body>
</html>
